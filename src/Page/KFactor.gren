module Page.KFactor exposing ( Model, Msg, init, update, view )

{-| The k factor page
-}

import Browser
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Math
import PageId
import SpaCmd exposing ( SpaCmd(..) )


type alias Model =
    { t : String
    , r : String
    , ba : String
    , a : String
    , k : String
    , xa : String
    }


type alias Updated =
    { model : Model
    , command : SpaCmd Msg
    }


init : Model
init =
    { t = ""
    , r = ""
    , ba = ""
    , a = "90"
    , k = ""
    , xa = ""
    }


type Msg
    = HomePage
    | UpdateThickness String
    | UpdateRadius String
    | UpdateAllowance String
    | UpdateAngle String
    | UpdateKFactor String
    | UpdateExtraAllowance String


update : Msg -> Model -> Updated
update msg model =
    case msg of
        HomePage ->
            { model = model
            , command = ChangePage PageId.Home
            }

        UpdateThickness s ->
            { model = { model | t = s }
            , command = SpaCmd.none
            }

        UpdateRadius s ->
            { model = { model | r = s }
            , command = SpaCmd.none
            }

        UpdateAllowance s ->
            { model = { model | ba = s }
            , command = SpaCmd.none
            }

        UpdateAngle s ->
            { model = { model | a = s }
            , command = SpaCmd.none
            }

        UpdateKFactor s ->
            { model = { model | k = s }
            , command = SpaCmd.none
            }

        UpdateExtraAllowance s ->
            { model = { model | xa = s }
            , command = SpaCmd.none
            }


type alias ParsedResult =
    { t : Maybe Float
    , r : Maybe Float
    , ba : Maybe Float
    , a : Maybe Float
    , k : Maybe Float
    , xa : Maybe Float
    }


type alias CalcResult =
    { t : Float
    , r : Float
    , ba : Float
    , a : Float
    , k : Float
    , xa : Float
    }


emptyResult =
    { t = Nothing
    , r = Nothing
    , ba = Nothing
    , a = Nothing
    , k = Nothing
    , xa = Nothing
    }


isJust : Maybe a -> Bool
isJust x =
    case x of
        Just _ ->
            True

        Nothing ->
            False


isJustInt : Maybe a -> Int
isJustInt x =
    case x of
        Just _ ->
            1

        Nothing ->
            0


parseModel : Model -> ParsedResult
parseModel model =
    let
        t =
            String.toFloat model.t

        r =
            String.toFloat model.r

        ba =
            String.toFloat model.ba

        a =
            String.toFloat model.a

        k =
            String.toFloat model.k

        xa =
            String.toFloat model.xa
    in
    { t = t
    , r = r
    , ba = ba
    , a = a
    , k = k
    , xa = xa
    }



-- calcXa : {t : Float, r : Float, a : Float, k : Float} -> CalcResult -> CalcResult
-- calcXa {t,r,a,k}model =
--    {model | xa = 
--    case model of
--        { t = Just t, r = Just r, a = Just a, k = Just k, xa = Nothing } ->
--    }
{- K Factor Formula


t = material thickness
r = bend radius
b = bend allowance
a = bend angle from horizontal (degrees)
k = K Factor
x = extra allowance (our own creation)

k = (-r + b / (pi * a / 180)) / t

    kt = -r + b / (pi * a / 180)
    kt + r = b / (pi * a / 180)

b = (kt + r) * (pi * a / 180)

t = (-r + b / (pi * a / 180)) / k

    kt + r = b / (pi * a / 180)

r = b / (pi * a / 180) - kt

    r + kt = b / (pi * a / 180)
    (r + kt) * a = b / (pi / 180)
    a = b / ((pi / 180) * (r + kt))

a = b / (pi * (r + kt) / 180)

k = (-r+(180*x+360*r*TAN(90/360*PI()))/(90*PI()))/t
k = (-r + (180x + 360r) / (90pi)) / t
k = (-r + (2x + 4r) / pi) / t
kt = -r + (2x + 4r) / pi


x=(pi / 2) * (kt + r) - 2r

k = (-r+(180*x+360*r*tan(a/2))/(a*PI))/t

kt = -r + (180x + 360r * tan(a/2)) / (a * pi)
kt + r = (180x + 360r * tan(a/2)) / (a * pi)

kt + r = 180x / (a * pi) + (360r * tan(a/2)) / (a * pi)

kt + r - (360r * tan(a/2)) / (a * pi) = 180x / (a * pi)

180x / (a * pi) = kt + r - (360r * tan(a/2)) / (a * pi)

180x = kt * a * pi + r * a * pi - 360r * tan(a/2)
x = pi * a * (kt + r) / 180 - 2r * tan(a/2)

---

x = Math.pi * a * (k * t + r) / 180 - 2 * r * Math.tan (Math.degrees a / 2)

find t

x + 2 * r * Math.tan (Math.degrees a / 2) = Math.pi * a * (k * t + r) / 180


((x + 2 * r * Math.tan (Math.degrees a / 2)) * 180 / (a * Math.pi)) - r = k * t



x = Math.pi * a * (k * t + r) / 180 - 2 * r * Math.tan (Math.degrees a / 2)
find r

r = (180 * x - Math.pi * a * k * t)/(Math.pi * a - 360 * Math.tan(Math.degrees a / 2))

 -}


fillXa :
    { t : Float
    , r : Float
    , ba : Float
    , a : Float
    , k : Float
    }
    -> CalcResult
fillXa { t, r, ba, a, k } =
    { t = t
    , r = r
    , ba = ba
    , a = a
    , k = k
    , xa = Math.pi * a * (k * t + r) / 180 - 2 * r * Math.tan (Math.degrees a / 2)
    }


fillBa :
    { t : Float
    , r : Float
    , a : Float
    , k : Float
    , xa : Float
    }
    -> CalcResult
fillBa { t, r, a, k, xa } =
    { t = t
    , r = r
    , ba = (Math.pi * (k * t + r)) / 180 * a
    , a = a
    , k = k
    , xa = xa
    }


finishCalc : ParsedResult -> Result String CalcResult
finishCalc m =
    let
        count =
            isJustInt m.t + isJustInt m.r + isJustInt m.ba + isJustInt m.a + isJustInt m.k + isJustInt m.xa
    in
    if count /= 4 then
        Err "I need four inputs"
    else
        case m of
            -- ....11
            -- ...1.1
            -- ..1..1
            -- .1...1
            -- 1....1
            -- ...11.
            -- ..1.1.
            -- .1..1.
            -- 1...1.
            -- ..11..
            -- .1.1..
            -- 1..1..
            -- .11...
            -- 1.1...
            -- 11....
            { t = Just t, r = Just r, ba = Just ba, a = Just a, k = Nothing, xa = Nothing } ->
                Ok
                    (fillXa
                        { t = t
                        , r = r
                        , ba = ba
                        , a = a
                        , k = (-r + (180 * ba) / (a * Math.pi)) / t
                        }
                    )

            { t = Just t, r = Just r, ba = Just ba, a = Nothing, k = Just k, xa = Nothing } ->
                Ok
                    (fillXa
                        { t = t
                        , r = r
                        , ba = ba
                        , a = ba / (Math.pi * (k * t + r) / 180)
                        , k = k
                        }
                    )

            { t = Just t, r = Just r, ba = Nothing, a = Just a, k = Just k, xa = Nothing } ->
                Ok
                    (fillXa
                        { t = t
                        , r = r
                        , ba = (Math.pi * (k * t + r)) / 180 * a
                        , a = a
                        , k = k
                        }
                    )

            { t = Just t, r = Nothing, ba = Just ba, a = Just a, k = Just k, xa = Nothing } ->
                Ok
                    (fillXa
                        { t = t
                        , r = -(k * t - 180 * ba / (Math.pi * a))
                        , ba = ba
                        , a = a
                        , k = k
                        }
                    )

            { t = Nothing, r = Just r, ba = Just ba, a = Just a, k = Just k, xa = Nothing } ->
                Ok
                    (fillXa
                        { t = (-r + ba / (Math.pi * a / 180)) / k
                        , r = r
                        , ba = ba
                        , a = a
                        , k = k
                        }
                    )

            { t = Nothing, r = Just r, ba = Nothing, a = Just a, k = Just k, xa = Just xa } ->
                Ok
                    (fillBa
                        { t = (((xa + 2 * r * Math.tan (Math.degrees a / 2)) * 180 / (a * Math.pi)) - r) / k
                        , r = r
                        , a = a
                        , k = k
                        , xa = xa
                        }
                    )

            { t = Just t, r = Nothing, ba = Nothing, a = Just a, k = Just k, xa = Just xa } ->
                Ok
                    (fillBa
                        { t = t
                        , r = (180 * xa - Math.pi * a * k * t) / (Math.pi * a - 360 * Math.tan (Math.degrees a / 2))
                        , a = a
                        , k = k
                        , xa = xa
                        }
                    )

            -- doesn't appear to have an easy solution
            -- { t = Just t,  r = Just r,  ba = Nothing, a = Nothing, k =  Just k, xa = Just xa } ->
            { t = Just t, r = Just r, ba = Nothing, a = Just a, k = Nothing, xa = Just xa } ->
                Ok
                    (fillBa
                        { t = t
                        , r = r
                        , a = a
                        , k = (((xa + 2 * r * Math.tan (Math.degrees a / 2)) * 180 / (a * Math.pi)) - r) / t
                        , xa = xa
                        }
                    )

            -- { t = Just t,  r = Just r,  ba = Just ba, a = Nothing, k = Nothing, xa = Just xa } ->
            -- { t = Just t,  r = Nothing, ba = Just ba, a =  Just a, k = Nothing, xa = Just xa } ->
            -- { t = Nothing, r = Just r,  ba = Just ba, a =  Just a, k = Nothing, xa = Just xa } ->
            -- { t = Just t,  r = Nothing, ba = Just ba, a = Nothing, k =  Just k, xa = Just xa } ->
            -- { t = Nothing, r = Just r,  ba = Just ba, a = Nothing, k =  Just k, xa = Just xa } ->
            -- { t = Nothing, r = Nothing, ba = Just ba, a =  Just a, k =  Just k, xa = Just xa } ->
            _ ->
                Err "todo"


view : Model -> Browser.Document Msg
view model =
    let
        parsedModel =
            parseModel model

        calculated =
            finishCalc parsedModel

        roundF : Float -> Float
        roundF value =
            toFloat (Math.round (value * 10000000000)) / 10000000000

        valIfNothing : Maybe Float -> Float -> Maybe Float
        valIfNothing parsed value =
            case parsed of
                Just _ ->
                    Nothing

                Nothing ->
                    Just (roundF value)

        res =
            case calculated of
                Ok { t, r, ba, a, k, xa } ->
                    { t = valIfNothing parsedModel.t t
                    , r = valIfNothing parsedModel.r r
                    , ba = valIfNothing parsedModel.ba ba
                    , a = valIfNothing parsedModel.a a
                    , k = valIfNothing parsedModel.k k
                    , xa = valIfNothing parsedModel.xa xa
                    }

                Err _ ->
                    { t = Nothing
                    , r = Nothing
                    , ba = Nothing
                    , a = Nothing
                    , k = Nothing
                    , xa = Nothing
                    }
    in
    { title = "K Factors"
    , body =
        [ button
            [ class "left"
            , onClick HomePage
            ]
            [ text "Home"
            ]
        , div
            [ id "k-factor"
            , class "center"
            ]
            [ case calculated of
                Ok _ ->
                    text ""

                Err e ->
                    text e
            , br [] []
            , text "Thickness:"
            , br [] []
            , case res.t of
                Just t ->
                    text (String.fromFloat t)

                Nothing ->
                    input
                        [ value model.t
                        , onInput UpdateThickness
                        ]
                        []
            , br [] []
            , text "Radius:"
            , br [] []
            , case res.r of
                Just r ->
                    text (String.fromFloat r)

                Nothing ->
                    input
                        [ value model.r
                        , onInput UpdateRadius
                        ]
                        []
            , br [] []
            , text "Bend Allowance:"
            , br [] []
            , case res.ba of
                Just ba ->
                    text (String.fromFloat ba)

                Nothing ->
                    input
                        [ value model.ba
                        , onInput UpdateAllowance
                        ]
                        []
            , br [] []
            , text "Angle:"
            , br [] []
            , case res.a of
                Just a ->
                    text (String.fromFloat a)

                Nothing ->
                    input
                        [ value model.a
                        , onInput UpdateAngle
                        ]
                        []
            , br [] []
            , text "K Factor:"
            , br [] []
            , case res.k of
                Just k ->
                    text (String.fromFloat k)

                Nothing ->
                    input
                        [ value model.k
                        , onInput UpdateKFactor
                        ]
                        []
            , br [] []
            , text "Extra Allowance:"
            , br [] []
            , case res.xa of
                Just xa ->
                    text (String.fromFloat xa)

                Nothing ->
                    input
                        [ value model.xa
                        , onInput UpdateExtraAllowance
                        ]
                        []
            ]
        ]
    }

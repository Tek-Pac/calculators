module Page.Truss exposing ( Model, Msg(..), update, view, queryParser, queryBuilder )

{-| The truss calculator page
-}

import Browser
import Browser.Dom as Dom
import Html exposing ( Html, a, br, button, div, h1, hr, input, table, tbody, td, text, th, thead, tr )
import Html.Attributes exposing ( class, href, id, readonly, step, style, tabindex, type_, value )
import Html.Events exposing ( onClick, onInput )
import Math
import SpaCmd exposing ( SpaCmd(..) )
import Svg exposing ( Svg, line, polyline, svg )
import Svg.Attributes exposing ( fill, points, stroke, strokeWidth, viewBox, width, x1, x2, y1, y2 )
import Task
import Url.Builder as Builder
import Url.Parser.Query as Query
import Vector2 as V2 exposing ( Float2, v2 )


qApply : Query.Parser a -> Query.Parser (a -> b) -> Query.Parser b
qApply argParser funcParser =
    Query.map2 (<|) funcParser argParser


queryParser : Query.Parser Model
queryParser =
    -- We can't do any more than map8
    Query.map
        (\chordLen chordGap chordOutside chordHeight chordDoubling web startWeb startCount nextWeb nextCount roof webAngle webStart webStartTop title ->
            let
                -- compatibility with old urls that include a gap rather than outside
                chordGapFM =
                    String.toFloat (Maybe.withDefault "" chordGap)

                chordHeightOriginalS =
                    Maybe.withDefault "" chordHeight

                chordHeightF =
                    Maybe.withDefault 0.0 (String.toFloat chordHeightOriginalS)

                chordOutsideS =
                    when chordGapFM is
                        Just chordGapF ->
                            String.fromFloat (chordGapF + chordHeightF * 2)

                        Nothing ->
                            Maybe.withDefault "" chordOutside

                chordHeightS =
                    when chordGapFM is
                        Just _ ->
                            if String.isEmpty chordHeightOriginalS then
                                "0"
                            else
                                chordHeightOriginalS

                        Nothing ->
                            chordHeightOriginalS

                webStartTopB =
                    when webStartTop is
                        Nothing ->
                            False

                        Just "no" ->
                            False

                        Just _ ->
                            True
            in
            { chordLen = Maybe.withDefault "" chordLen
            , chordOutside = chordOutsideS
            , chordHeight = chordHeightS
            , chordDoubling = Maybe.withDefault "" chordDoubling
            , web = Maybe.withDefault "" web
            , startWeb = Maybe.withDefault "" startWeb
            , startCount = Maybe.withDefault "" startCount
            , nextWeb = Maybe.withDefault "" nextWeb
            , nextCount = Maybe.withDefault "" nextCount
            , roof = Maybe.withDefault "" roof
            , webAngle = Maybe.withDefault "45" webAngle
            , webStart = Maybe.withDefault "125" webStart
            , webStartTop = webStartTopB
            , title = Maybe.withDefault "Truss" title
            , titleEdit = False
            }
        )
        (Query.string "chordLen")
        |> qApply (Query.string "chordGap")
        |> qApply (Query.string "chordOutside")
        |> qApply (Query.string "chordHeight")
        |> qApply (Query.string "chordDoubling")
        |> qApply (Query.string "web")
        |> qApply (Query.string "startWeb")
        |> qApply (Query.string "startCount")
        |> qApply (Query.string "nextWeb")
        |> qApply (Query.string "nextCount")
        |> qApply (Query.string "roof")
        |> qApply (Query.string "webAngle")
        |> qApply (Query.string "webStart")
        |> qApply (Query.string "webStartTop")
        |> qApply (Query.string "title")


builderStr : String -> String -> String -> Maybe Builder.QueryParameter
builderStr default key val =
    if val == default then
        Nothing
    else
        Just (Builder.string key val)


queryBuilder : Model -> Array Builder.QueryParameter
queryBuilder model =
    [ builderStr "" "chordLen" model.chordLen
    , builderStr "" "chordOutside" model.chordOutside
    , builderStr "" "chordHeight" model.chordHeight
    , builderStr "" "chordDoubling" model.chordDoubling
    , builderStr "" "web" model.web
    , builderStr "" "startWeb" model.startWeb
    , builderStr "" "startCount" model.startCount
    , builderStr "" "nextWeb" model.nextWeb
    , builderStr "" "nextCount" model.nextCount
    , builderStr "" "roof" model.roof
    , builderStr "45" "webAngle" model.webAngle
    , builderStr "125" "webStart" model.webStart
    , if model.webStartTop then
        Just (Builder.string "webStartTop" "yes")
      else
        Nothing
    , builderStr "Truss" "title" model.title
    ]
        |> Array.mapAndKeepJust identity


type alias Model =
    { chordLen : String
    , chordOutside : String
    , chordHeight : String
    , chordDoubling : String
    , web : String
    , startWeb : String
    , startCount : String
    , nextWeb : String
    , nextCount : String
    , roof : String
    , webAngle : String
    , webStart : String
    , webStartTop : Bool
    , title : String
    , titleEdit : Bool
    }


type alias Updated =
    { model : Model
    , command : SpaCmd Msg
    }


type Msg
    = UpdateChordLen String
    | UpdateChordOutside String
    | UpdateChordHeight String
    | UpdateChordDoubling String
    | UpdateWeb String
    | UpdateStartWeb String
    | UpdateStartCount String
    | UpdateNextWeb String
    | UpdateNextCount String
    | UpdateRoof String
    | UpdateWebAngle String
    | UpdateWebStart String
    | ToggleWebStartTop
    | UpdateTitle String
    | ToggleTitleEdit
    | DoCopy String
    | NoOp


attemptFocus : String -> SpaCmd Msg
attemptFocus id =
    BaseCmd (Task.attempt (\_ -> NoOp) (Dom.focus id))


doFocus : Model -> String -> Updated
doFocus model id =
    { model = model
    , command = attemptFocus id
    }


update : Msg -> Model -> Updated
update msg model =
    when msg is
        NoOp ->
            { model = model
            , command = SpaCmd.none
            }

        UpdateChordLen c ->
            doFocus { model | chordLen = c } "chord-len"

        UpdateChordOutside c ->
            doFocus { model | chordOutside = c } "chord-outside"

        UpdateChordHeight c ->
            doFocus { model | chordHeight = c } "chord-height"

        UpdateChordDoubling c ->
            doFocus { model | chordDoubling = c } "chord-doubling"

        UpdateWeb w ->
            doFocus { model | web = w } "web"

        UpdateStartWeb s ->
            doFocus { model | startWeb = s } "start-web"

        UpdateStartCount s ->
            doFocus { model | startCount = s } "start-count"

        UpdateNextWeb s ->
            doFocus { model | nextWeb = s } "next-web"

        UpdateNextCount s ->
            doFocus { model | nextCount = s } "next-count"

        UpdateRoof r ->
            doFocus { model | roof = r } "roof"

        UpdateWebAngle w ->
            doFocus { model | webAngle = w } "web-angle"

        UpdateWebStart w ->
            doFocus { model | webStart = w } "web-start"

        ToggleWebStartTop ->
            { model = { model | webStartTop = not model.webStartTop }
            , command = SpaCmd.none
            }

        UpdateTitle w ->
            { model = { model | title = w }
            , command = SpaCmd.none
            }

        ToggleTitleEdit ->
            { model = { model | titleEdit = not model.titleEdit }
            , command =
                if not model.titleEdit then
                    attemptFocus "title"
                else
                    SpaCmd.none
            }

        DoCopy id ->
            { model = model
            , command = CopyId id
            }


calculateTruss : Model -> Result String TrussCalc
calculateTruss model =
    let
        parsedModel =
            { chordLen = String.toFloat model.chordLen
            , chordOutside = String.toFloat model.chordOutside
            , chordHeight = String.toFloat model.chordHeight
            , chordDoubling = String.toInt model.chordDoubling
            , web = String.toFloat model.web
            , startWeb = String.toFloat model.startWeb
            , startCount = String.toInt model.startCount
            , nextWeb = String.toFloat model.nextWeb
            , nextCount = String.toInt model.nextCount
            , roof = String.toFloat model.roof
            , webAngle = String.toFloat model.webAngle
            , webStart = String.toFloat model.webStart
            }
    in
    when parsedModel is
        -- same webs all through
        { chordLen = Just chordLen, chordOutside = Just chordOutside, chordHeight = Just chordHeight, web = Just web, startWeb = Nothing, startCount = Nothing, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordOutside - chordHeight * 2
                , chordHeight = chordHeight
                , chordDoubling = Maybe.withDefault 0 parsedModel.chordDoubling
                , web = web
                , startWeb = 0
                , startCount = 0
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                , webStartTop = model.webStartTop
                }

        -- two sorts of webs
        { chordLen = Just chordLen, chordOutside = Just chordOutside, chordHeight = Just chordHeight, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordOutside - chordHeight * 2
                , chordHeight = chordHeight
                , chordDoubling = Maybe.withDefault 0 parsedModel.chordDoubling
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                , webStartTop = model.webStartTop
                }

        -- three sorts of webs
        { chordLen = Just chordLen, chordOutside = Just chordOutside, chordHeight = Just chordHeight, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Just nextWeb, nextCount = Just nextCount, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordOutside - chordHeight * 2
                , chordHeight = chordHeight
                , chordDoubling = Maybe.withDefault 0 parsedModel.chordDoubling
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = nextWeb
                , nextCount = nextCount
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                , webStartTop = model.webStartTop
                }

        { chordLen = Nothing } ->
            Err "enter the length of the chord"

        { chordOutside = Nothing } ->
            Err "enter the truss depth"

        { chordHeight = Nothing } ->
            Err "enter the height of the chord profile"

        { web = Nothing } ->
            Err "enter the width of the web profile"

        { roof = Nothing } ->
            Err "enter the angle of the roof"

        { webAngle = Nothing } ->
            Err "enter the angle that you want the webs to be at"

        { webStart = Nothing } ->
            Err "enter the web start distance"

        -- Check the initial webs
        -- The user has entered an initial web width, but not a valid count
        { startCount = Nothing } ->
            when String.toFloat model.startCount is
                Just _ ->
                    -- the user has entered something like 3.5
                    Err "enter an integral number of initial webs"

                Nothing ->
                    -- the user hasn't entered anything
                    Err "enter the number of initial webs too"

        -- The user has entered an initial web count, but not a width
        { startWeb = Nothing } ->
            Err "enter the size of the initial webs"

        -- Check the next webs
        -- The user has entered a next web width, but not a valid count
        { nextCount = Nothing } ->
            when String.toFloat model.nextCount is
                Just _ ->
                    -- the user has entered something like 3.5
                    Err "enter an integral number of next webs"

                Nothing ->
                    -- the user hasn't entered anything
                    Err "enter the number of next webs too"

        -- The user has entered a next web count, but not a width
        { nextWeb = Nothing } ->
            Err "enter the size of the next webs"


view : Model -> Browser.Document Msg
view model =
    { title = model.title
    , body =
        [ a
            [ class "left"
            , href "#/"
            ]
            [ text "Home"
            ]
        , if String.isEmpty model.roof then
            text ""
          else
            let
                roofAngle =
                    String.toFloat model.roof
                        |> Maybe.withDefault 7.5

                bStr =
                    String.toFloat model.chordLen
                        |> Maybe.map
                                (\c ->
                                    let
                                        b =
                                            c * Math.cos (Math.degrees roofAngle)

                                        -- 2 d.p.
                                        roundB =
                                            toFloat (Math.round (b * 100)) / 100
                                    in
                                    String.fromFloat roundB
                                )
                        |> Maybe.withDefault ""
            in
            a
                [ class "right"
                , href ("#/triangle?b=" ++ bStr ++ "&theta=" ++ String.fromFloat roofAngle)
                ]
                [ text "Roof Triangle"
                ]
        , div
            [ id "truss"
            , class "center"
            ]
            [ h1
                []
                [ if model.titleEdit then
                    input
                        [ value model.title
                        , onInput UpdateTitle
                        , id "title"
                        ]
                        []
                  else
                    text model.title
                , text " "
                , button
                    [ onClick ToggleTitleEdit
                    ]
                    [ text "✏️"
                    ]
                ]
            , br [] []
            , div
                [ id "truss-inputs"
                , class "center-margin"
                , class "cols-large"
                , style "max-width" "60em"
                ]
                [ makeInput "Chord length" "chord-len" 0.5 model.chordLen UpdateChordLen
                , makeInput "Truss depth" "chord-outside" 0.5 model.chordOutside UpdateChordOutside
                , makeInput "Chord height" "chord-height" 0.5 model.chordHeight UpdateChordHeight
                , makeInput "Chord doubling count" "chord-doubling" 1 model.chordDoubling UpdateChordDoubling
                , makeInput "Roof angle" "roof" 0.5 model.roof UpdateRoof
                , makeInput "Web start distance" "web-start" 5 model.webStart UpdateWebStart
                , div
                    []
                    [ text "Webs start at "
                    , button
                        [ onClick ToggleWebStartTop
                        , id "web-start-top"
                        ]
                        [ text
                            (if model.webStartTop then
                                "top"
                             else
                                "bottom"
                            )
                        ]
                    ]
                , makeInput "Web profile width" "web" 0.5 model.web UpdateWeb
                , makeInput "Initial web profile width" "start-web" 0.5 model.startWeb UpdateStartWeb
                , makeInput "Initial web count" "start-count" 1 model.startCount UpdateStartCount
                , makeInput "Next web profile width" "next-web" 0.5 model.nextWeb UpdateNextWeb
                , makeInput "Next web count" "next-count" 1 model.nextCount UpdateNextCount
                , makeInput "Web angle" "web-angle" 0.1 model.webAngle UpdateWebAngle
                ]
            , hr [] []
            , when calculateTruss model is
                Err e ->
                    div
                        [ class "center"
                        ]
                        [ text e
                        ]

                Ok { endDistance, webPoints, webLines, lowerChordStart, upperChordStart, lowerChordEnd, upperChordEnd, webOffsetDn, webOffsetUp, chordDoublingRes, chordVert, members } ->
                    let
                        trussWidth =
                            upperChordEnd.x

                        isDown =
                            upperChordEnd.y < upperChordStart.y

                        trussHeight =
                            if isDown then
                                upperChordStart.y - lowerChordEnd.y + chordVert.y + chordVert.y
                            else
                                upperChordEnd.y + chordVert.y + chordVert.y

                        assumedWidth =
                            1000.0

                        -- 1 pixel in the final
                        sw =
                            trussWidth * 1.0 / assumedWidth

                        vbWidth =
                            trussWidth + sw * 2

                        vbHeight =
                            trussHeight + sw * 2

                        changeCoords : Float2 -> Float2
                        changeCoords { x, y } =
                            { x = x + sw
                            , y =
                                if isDown then
                                    upperChordStart.y - y + sw + chordVert.y
                                else
                                    trussHeight - y + sw - chordVert.y
                            }

                        webLinesMap =
                            webLines
                                |> Array.map
                                        (\{ start, end } ->
                                            { start = changeCoords start
                                            , end = changeCoords end
                                            }
                                        )
                    in
                    div
                        [ class "center"
                        ]
                        [ makeOutput "End distance" "end-distance" endDistance
                        , makeOutputLine "Up distance" "up-distance" webOffsetUp
                        , makeOutputLine "Dn distance" "dn-distance" webOffsetDn
                        , makeOutputTable members
                        , svg
                            [ -- fill the screen when it is small
                              style "width" "clamp(75%, 1000px, 100%)"
                            , viewBox ("0 0 " ++ String.fromFloat vbWidth ++ " " ++ String.fromFloat vbHeight)
                            ]
                            (lines
                                sw
                                (webLinesMap
                                    -- left line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.sub lowerChordStart chordVert)
                                            , end = changeCoords (V2.add upperChordStart chordVert)
                                            }
                                    -- top outer line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.add upperChordStart chordVert)
                                            , end = changeCoords (V2.add upperChordEnd chordVert)
                                            }
                                    -- top inner line
                                    |> Array.pushLast
                                            { start = changeCoords upperChordStart
                                            , end = changeCoords upperChordEnd
                                            }
                                    -- right line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.sub lowerChordEnd chordVert)
                                            , end = changeCoords (V2.add upperChordEnd chordVert)
                                            }
                                    -- bottom outer line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.sub lowerChordStart chordVert)
                                            , end = changeCoords (V2.sub lowerChordEnd chordVert)
                                            }
                                    -- bottom inner line
                                    |> Array.pushLast
                                            { start = changeCoords lowerChordStart
                                            , end = changeCoords lowerChordEnd
                                            }
                                )
                                |> Array.pushLast
                                        (when chordDoublingRes is
                                            Just { start, end } ->
                                                doLine sw (changeCoords start) (changeCoords end)

                                            Nothing ->
                                                text ""
                                        )
                            )
                        ]
            ]
        ]
    }


doLine : Float -> Float2 -> Float2 -> Svg msg
doLine sw start end =
    line
        [ x1 (String.fromFloat start.x)
        , y1 (String.fromFloat start.y)
        , x2 (String.fromFloat end.x)
        , y2 (String.fromFloat end.y)
        , stroke "var(--text)"
        , strokeWidth (String.fromFloat sw)
        ]
        []


lines : Float -> Array LineSeg2 -> Array (Svg msg)
lines sw linesArr =
    linesArr
        |> Array.map (\ls -> doLine sw ls.start ls.end)


polylineF : Float -> Array Float2 -> Svg msg
polylineF sw pointsArr =
    polyline
        [ points
            (pointsArr
                |> Array.map (\{ x, y } -> String.fromFloat x ++ "," ++ String.fromFloat y)
                |> Array.intersperse " "
                |> Array.foldl (++) ""
            )
        , fill "none"
        , stroke "var(--text)"
        , strokeWidth (String.fromFloat sw)
        ]
        []


type alias InputData =
    { label : String
    , idTxt : String
    , stepV : Float
    , currTxt : String
    , updateMsg : String -> Msg
    }


makeInput : String -> String -> Float -> String -> (String -> Msg) -> Html Msg
makeInput label idTxt stepV currTxt updateMsg =
    div
        []
        [ text label
        , br [] []
        , text "         "
        , input
            [ value currTxt
            , onInput updateMsg
            , id idTxt
            , type_ "number"
            , step (String.fromFloat stepV)
            ]
            []
        , if String.isEmpty currTxt then
            button
                [ style "pointer-events" "none"
                , style "opacity" "0"
                , tabindex -1
                ]
                [ text "❌"
                ]
          else
            button
                [ onClick (updateMsg "")
                ]
                [ text "❌"
                ]
        ]


makeOutput : String -> String -> Float -> Html Msg
makeOutput label idTxt calc =
    div
        []
        [ text label
        , br [] []
        , text "         "
        , input
            [ value (String.fromFloat calc)
            , readonly True
            , id idTxt
            , type_ "number"
            ]
            []
        , button
            [ onClick (DoCopy idTxt)
            ]
            [ text "📋"
            ]
        ]


makeOutputLine : String -> String -> Float2 -> Html Msg
makeOutputLine label idTxt { x, y } =
    let
        idX =
            idTxt ++ "-x"

        idY =
            idTxt ++ "-y"
    in
    div
        []
        [ text label
        , br [] []
        , text "         "
        , input
            [ value (String.fromFloat x)
            , readonly True
            , id idX
            , type_ "number"
            ]
            []
        , button
            [ onClick (DoCopy idX)
            ]
            [ text "📋"
            ]
        , input
            [ value (String.fromFloat y)
            , readonly True
            , id idY
            , type_ "number"
            ]
            []
        , button
            [ onClick (DoCopy idY)
            ]
            [ text "📋"
            ]
        ]


makeOutputTable : MemberList -> Html Msg
makeOutputTable members =
    table
        [ style "margin-left" "auto"
        , style "margin-right" "auto"
        ]
        [ thead
            []
            [ tr
                []
                [ th
                    []
                    [ text "Member Type"
                    ]
                , th
                    []
                    [ text "Length"
                    ]
                , th
                    []
                    [ text "Qty"
                    ]
                ]
            ]
        , tbody
            []
            (members
                |> Array.sortWith compareMembers
                |> Array.map
                        (\{ name, length, qty } ->
                            tr
                                []
                                [ td
                                    []
                                    [ text name
                                    ]
                                , td
                                    []
                                    [ text (String.fromFloat (formatFs length))
                                    ]
                                , td
                                    []
                                    [ text (String.fromInt qty)
                                    ]
                                ]
                        )
            )
        ]



-- chordHeight is 90 degrees to the chord


type alias WebData =
    { endPoint : Float2
    , webs :
        { offsets :
            { webOffsetUp : Float2
            , webOffsetDn : Float2
            , webOffsetUpCd : Float2
            , webOffsetDnCd : Float2
            , webOffsetVec : Float2
            }
        , mainWebWidth : Float
        , startWebWidth : Float
        , nextWebWidth : Float
        , startCount : Int
        , nextCount : Int
        , webWidthToLenMul : Float
        , webStartTop : Bool
        }
    , chordDoubling : Int
    , chordVert : Float2
    , mainChordLen : Float
    }


type alias Member =
    { name : String
    , length : Float
    , qty : Int
    }


type alias MemberList =
    Array Member


memberToNum : Member -> Int
memberToNum member =
    when member.name is
        "Chord" ->
            0

        "Initial Web" ->
            1

        "Next Web" ->
            2

        "Main Web" ->
            3

        _ ->
            4


compareMembers : Member -> Member -> Order
compareMembers a b =
    when compare (memberToNum a) (memberToNum b) is
        EQ ->
            compare b.length a.length
            -- length largest to smallest

        LT ->
            LT

        GT ->
            GT


canCombineMembers : String -> Float -> Member -> Bool
canCombineMembers name length =
    \member -> member.name == name && (Math.abs (member.length - length) < 1)


addMember : String -> Float -> MemberList -> MemberList
addMember name length existing =
    when Array.findFirst (canCombineMembers name length) existing is
        Just { index = i, value = existingMember } ->
            existing
                |> Array.set
                        i
                        { existingMember | qty = existingMember.qty + 1 }

        Nothing ->
            existing
                |> Array.pushLast
                        { name = name
                        , length = length
                        , qty = 1
                        }


calcWebPoints :
    WebData
    -> Float2
    -> Int
    -> { webPoints : Array Float2
       , webLines : Array LineSeg2
       , chordDoublingRes :
            Maybe
                { start : Float2
                , end : Float2
                , wholeLength : Bool
                }
       , members : MemberList
       }
calcWebPoints dat currWeb index =
    let
        { endPoint, webs, chordDoubling, chordVert, mainChordLen } =
            dat

        { offsets, mainWebWidth, startWebWidth, nextWebWidth, startCount, nextCount, webWidthToLenMul, webStartTop } =
            webs

        { webOffsetUp, webOffsetUpCd, webOffsetDn, webOffsetDnCd, webOffsetVec } =
            offsets
    in
    if currWeb.x > endPoint.x then
        { webPoints = []
        , webLines = []
        , chordDoublingRes = Nothing
        , members =
            []
                |> addMember "Chord" mainChordLen
                |> addMember "Chord" mainChordLen
        }
    else
        let
            isTop =
                if webStartTop then
                    -- index is even && webStartTop -> true
                    -- index is odd  && webStartTop -> false
                    Math.modBy 2 index == 0
                else
                    -- index is even && not webStartTop -> false
                    -- index is odd  && not webStartTop -> true
                    Math.modBy 2 index == 1

            chordDoublingEndIndex =
                chordDoubling
                    * 2
                    - 1
                    + (if webStartTop then
                            -1
                         else
                            0
                        )

            webWidth =
                if index < startCount then
                    startWebWidth
                else if index < startCount + nextCount then
                    nextWebWidth
                else
                    mainWebWidth

            webOffset =
                V2.mul webOffsetVec webWidth

            webLen =
                if index < chordDoublingEndIndex then
                    V2.length webOffsetDnCd + webWidthToLenMul * webWidth
                else
                    V2.length webOffsetDn + webWidthToLenMul * webWidth

            webStartGraphicalOffset =
                if index == 0 && chordDoubling > 0 && not webStartTop then
                    chordVert
                else
                    v2 0 0

            webOffsetDir =
                if index < chordDoublingEndIndex then
                    -- if webStartTop == true
                    --  1 goes to just before the first web
                    --  2 goes to just before the third web
                    -- else (webStartTop == false)
                    --  1 goes to just before the second web
                    --  2 goes to just before the fourth web
                    if isTop then
                        webOffsetDnCd
                    else if index == 0 then
                        -- never hit if webStartTop == true
                        V2.add webOffsetUpCd chordVert
                    else
                        webOffsetUpCd
                else if isTop then
                    webOffsetDn
                else
                    webOffsetUp

            nextCurrWeb =
                webOffsetDir
                    |> V2.add currWeb
                    |> V2.add webOffset

            nextDat =
                calcWebPoints dat nextCurrWeb (index + 1)

            isNextWeb =
                not (Array.isEmpty nextDat.webPoints)

            webPoints =
                nextDat.webPoints
                    |> Array.pushFirst currWeb

            webLines =
                if isNextWeb then
                    nextDat.webLines
                        |> Array.pushFirst
                                { start = V2.add currWeb webStartGraphicalOffset
                                , end = V2.add currWeb webOffsetDir
                                }
                        |> Array.pushFirst
                                { start = V2.add (V2.add currWeb webOffset) webStartGraphicalOffset
                                , end = nextCurrWeb
                                }
                else
                    []

            addedChordDouble =
                if not isNextWeb && index <= chordDoublingEndIndex then
                    -- chord doubling the whole length
                    addMember "Chord" mainChordLen nextDat.members
                else if index == chordDoublingEndIndex then
                    -- chord doubling ends at this web
                    -- index is the down web
                    addMember "Chord" (V2.length (V2.add currWeb webOffsetDir)) nextDat.members
                else
                    nextDat.members

            addedStartWeb =
                if index < startCount && isNextWeb then
                    addMember "Initial Web" webLen addedChordDouble
                else
                    addedChordDouble

            addedNextWeb =
                if index >= startCount && index < startCount + nextCount && isNextWeb then
                    addMember "Next Web" webLen addedStartWeb
                else
                    addedStartWeb

            addedMainWeb =
                if index >= startCount + nextCount && isNextWeb then
                    addMember "Main Web" webLen addedNextWeb
                else
                    addedNextWeb

            members =
                addedMainWeb

            chordDoublingRes =
                if not isNextWeb && index <= chordDoublingEndIndex then
                    -- chord doubling the whole length
                    Just
                        { start = chordVert
                        , end = V2.add chordVert endPoint
                        , wholeLength = True
                        }
                else if index == chordDoublingEndIndex then
                    -- chord doubling ends at this web
                    -- index is the down web
                    Just
                        { start = chordVert
                        , end = V2.add currWeb webOffsetDnCd
                        , wholeLength = False
                        }
                else
                    nextDat.chordDoublingRes
        in
        { webPoints = webPoints
        , webLines = webLines
        , chordDoublingRes = chordDoublingRes
        , members = members
        }


type alias FilledModel =
    { chordLen : Float
    , chordGap : Float
    , chordHeight : Float
    , chordDoubling : Int
    , web : Float
    , startWeb : Float
    , startCount : Int
    , nextWeb : Float
    , nextCount : Int
    , roof : Float
    , webAngle : Float
    , webStart : Float
    , webStartTop : Bool
    }


type alias LineSeg2 =
    { start : Float2
    , end : Float2
    }


type alias TrussCalc =
    { endDistance : Float
    , webPoints : Array Float2
    , webLines : Array LineSeg2
    , lowerChordStart : Float2
    , upperChordStart : Float2
    , lowerChordEnd : Float2
    , upperChordEnd : Float2
    , chordDoublingRes :
        Maybe
            { start : Float2
            , end : Float2
            , wholeLength : Bool
            }
    , webOffsetUp : Float2
    , webOffsetDn : Float2
    , chordVert : Float2
    , members : MemberList
    }


maybeErr : x -> Bool -> Maybe x -> Maybe x
maybeErr err useDefault orig =
    when orig is
        Nothing ->
            if useDefault then
                Just err
            else
                Nothing

        _ ->
            orig


finishTrussCalc : FilledModel -> Result String TrussCalc
finishTrussCalc { chordLen, chordGap, chordHeight, chordDoubling, web, startWeb, startCount, nextWeb, nextCount, roof, webAngle, webStart, webStartTop } =
    let
        roofRad =
            Math.degrees roof

        webRad =
            Math.degrees webAngle

        trussAlong =
            v2 (Math.cos roofRad) (Math.sin roofRad)

        webAlongUp =
            v2 (Math.cos (roofRad + webRad)) (Math.sin (roofRad + webRad))

        webAlongDn =
            v2 (Math.cos (roofRad - webRad)) (Math.sin (roofRad - webRad))

        vertGapDist =
            v2 0 (chordGap / Math.cos roofRad)

        endPointLower =
            V2.mul trussAlong chordLen

        endPointUpper =
            V2.add endPointLower vertGapDist

        webStartV =
            if webStartTop then
                V2.add (V2.mul trussAlong webStart) vertGapDist
            else
                V2.mul trussAlong webStart

        webOffsetUp =
            V2.div (V2.mul webAlongUp chordGap) (Math.sin webRad)

        webOffsetDn =
            V2.div (V2.mul webAlongDn chordGap) (Math.sin webRad)

        webOffsetUpCd =
            V2.div (V2.mul webAlongUp (chordGap - chordHeight)) (Math.sin webRad)

        webOffsetDnCd =
            V2.div (V2.mul webAlongDn (chordGap - chordHeight)) (Math.sin webRad)

        chordVert =
            v2 0 (chordHeight / Math.cos roofRad)

        mainChordLen =
            chordLen + (chordHeight * Math.tan roofRad)

        dat =
            calcWebPoints
                { endPoint = endPointLower
                , webs =
                    { offsets =
                        { webOffsetUp = webOffsetUp
                        , webOffsetDn = webOffsetDn
                        , webOffsetUpCd = webOffsetUpCd
                        , webOffsetDnCd = webOffsetDnCd
                        , webOffsetVec = V2.div trussAlong (Math.sin webRad)
                        }
                    , mainWebWidth = web
                    , startWebWidth = startWeb
                    , nextWebWidth = nextWeb
                    , startCount = startCount
                    , nextCount = nextCount
                    , webWidthToLenMul = 1 / Math.tan webRad
                    , webStartTop = webStartTop
                    }
                , chordDoubling = chordDoubling
                , chordVert = chordVert
                , mainChordLen = mainChordLen
                }
                webStartV
                0

        endDistance =
            Array.last dat.webPoints
                |> Maybe.withDefault (v2 0 9999)
                |> (if
                        Math.modBy 2 (Array.length dat.webPoints)
                            == (if webStartTop then
                                    0
                                 else
                                    1
                                )
                     then
                        when dat.chordDoublingRes is
                            Just { end, wholeLength = True } ->
                                V2.distance end

                            _ ->
                                V2.distance endPointLower
                     else
                        V2.distance endPointUpper
                    )

        webMax =
            90 - Math.abs roof

        -- chordLen, chordGap, chordHeight, chordDoubling, web, startWeb, startCount, nextWeb, nextCount, roof, webAngle, webStart
        error =
            Nothing
                |> maybeErr "chord length should be positive" (chordLen < 0)
                |> maybeErr "gap between chords should be positive" (chordGap < 0)
                |> maybeErr "chord height should be positive" (chordHeight < 0)
                |> maybeErr "chord doubling count should be positive" (chordDoubling < 0)
                |> maybeErr "web profile width should be positive" (web < 0)
                |> maybeErr "initial web profile width should be positive" (startWeb < 0)
                |> maybeErr "initial web count should be positive" (startCount < 0)
                |> maybeErr "next web profile width should be positive" (nextWeb < 0)
                |> maybeErr "next web count should be positive" (nextCount < 0)
                |> maybeErr ("web angle should be less than " ++ String.fromFloat webMax ++ " degrees") (webAngle > webMax)
                |> maybeErr "web angle should be positive" (webAngle < 0)
                |> maybeErr "web start distance should be positive" (webStart < 0)
    in
    when error is
        Just e ->
            Err e

        Nothing ->
            Ok
                { endDistance = formatFs endDistance
                , webPoints = dat.webPoints
                , webLines = dat.webLines
                , lowerChordStart =
                    { x = 0.0
                    , y = 0.0
                    }
                , lowerChordEnd = endPointLower
                , upperChordStart = vertGapDist
                , upperChordEnd = endPointUpper
                , chordDoublingRes = dat.chordDoublingRes
                , webOffsetUp = formatF2 webOffsetUp
                , webOffsetDn = formatF2 webOffsetDn
                , chordVert = chordVert
                , members = dat.members
                }



-- 6 dp


formatF2 : Float2 -> Float2
formatF2 { x, y } =
    { x = toFloat (Math.round (x * 1000000)) / 1000000
    , y = toFloat (Math.round (y * 1000000)) / 1000000
    }



-- 2 dp


formatFs : Float -> Float
formatFs value =
    toFloat (Math.round (value * 100)) / 100

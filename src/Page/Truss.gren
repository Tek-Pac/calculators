module Page.Truss exposing ( Model, Msg(..), update, view, queryParser, queryBuilder )

{-| The truss calculator page
-}

import Browser
import Browser.Dom as Dom
import Html exposing ( Html, br, button, div, h1, hr, input, text )
import Html.Attributes exposing ( class, id, readonly, step, style, tabindex, type_, value )
import Html.Events exposing ( onClick, onInput )
import Math
import SpaCmd exposing ( SpaCmd(..) )
import Svg exposing ( Svg, line, polyline, svg )
import Svg.Attributes exposing ( fill, points, stroke, strokeWidth, viewBox, width, x1, x2, y1, y2 )
import Task
import Url.Builder as Builder
import Url.Parser.Query as Query
import Vector2 as V2 exposing ( Float2, v2 )


qApply : Query.Parser a -> Query.Parser (a -> b) -> Query.Parser b
qApply argParser funcParser =
    Query.map2 (<|) funcParser argParser


queryParser : Query.Parser Model
queryParser =
    -- We can't do any more than map8
    Query.map
        (\chordLen chordGap chordHeight chordDoubling web startWeb startCount nextWeb nextCount roof webAngle webStart ->
            { chordLen = Maybe.withDefault "" chordLen
            , chordGap = Maybe.withDefault "" chordGap
            , chordHeight = Maybe.withDefault "" chordHeight
            , chordDoubling = Maybe.withDefault "" chordDoubling
            , web = Maybe.withDefault "" web
            , startWeb = Maybe.withDefault "" startWeb
            , startCount = Maybe.withDefault "" startCount
            , nextWeb = Maybe.withDefault "" nextWeb
            , nextCount = Maybe.withDefault "" nextCount
            , roof = Maybe.withDefault "" roof
            , webAngle = Maybe.withDefault "45" webAngle
            , webStart = Maybe.withDefault "125" webStart
            }
        )
        (Query.string "chordLen")
        |> qApply (Query.string "chordGap")
        |> qApply (Query.string "chordHeight")
        |> qApply (Query.string "chordDoubling")
        |> qApply (Query.string "web")
        |> qApply (Query.string "startWeb")
        |> qApply (Query.string "startCount")
        |> qApply (Query.string "nextWeb")
        |> qApply (Query.string "nextCount")
        |> qApply (Query.string "roof")
        |> qApply (Query.string "webAngle")
        |> qApply (Query.string "webStart")


queryBuilder : Model -> Array Builder.QueryParameter
queryBuilder model =
    [ Builder.string "chordLen" model.chordLen
    , Builder.string "chordGap" model.chordGap
    , Builder.string "chordHeight" model.chordHeight
    , Builder.string "chordDoubling" model.chordDoubling
    , Builder.string "web" model.web
    , Builder.string "startWeb" model.startWeb
    , Builder.string "startCount" model.startCount
    , Builder.string "nextWeb" model.nextWeb
    , Builder.string "nextCount" model.nextCount
    , Builder.string "roof" model.roof
    , Builder.string "webAngle" model.webAngle
    , Builder.string "webStart" model.webStart
    ]


type alias Model =
    { chordLen : String
    , chordGap : String
    , chordHeight : String
    , chordDoubling : String
    , web : String
    , startWeb : String
    , startCount : String
    , nextWeb : String
    , nextCount : String
    , roof : String
    , webAngle : String
    , webStart : String
    }


type alias Updated =
    { model : Model
    , command : SpaCmd Msg
    }


type Msg
    = HomePage
    | UpdateChordLen String
    | UpdateChordGap String
    | UpdateChordHeight String
    | UpdateChordDoubling String
    | UpdateWeb String
    | UpdateStartWeb String
    | UpdateStartCount String
    | UpdateNextWeb String
    | UpdateNextCount String
    | UpdateRoof String
    | UpdateWebAngle String
    | UpdateWebStart String
    | DoCopy String
    | NoOp


attemptFocus : String -> SpaCmd Msg
attemptFocus id =
    BaseCmd (Task.attempt (\_ -> NoOp) (Dom.focus id))


doFocus : Model -> String -> Updated
doFocus model id =
    { model = model
    , command = attemptFocus id
    }


update : Msg -> Model -> Updated
update msg model =
    case msg of
        NoOp ->
            { model = model
            , command = SpaCmd.none
            }

        HomePage ->
            { model = model
            , command = ChangePage "#/"
            }

        UpdateChordLen c ->
            doFocus { model | chordLen = c } "chord-len"

        UpdateChordGap c ->
            doFocus { model | chordGap = c } "chord-gap"

        UpdateChordHeight c ->
            doFocus { model | chordHeight = c } "chord-height"

        UpdateChordDoubling c ->
            doFocus { model | chordDoubling = c } "chord-doubling"

        UpdateWeb w ->
            doFocus { model | web = w } "web"

        UpdateStartWeb s ->
            doFocus { model | startWeb = s } "start-web"

        UpdateStartCount s ->
            doFocus { model | startCount = s } "start-count"

        UpdateNextWeb s ->
            doFocus { model | nextWeb = s } "next-web"

        UpdateNextCount s ->
            doFocus { model | nextCount = s } "next-count"

        UpdateRoof r ->
            doFocus { model | roof = r } "roof"

        UpdateWebAngle w ->
            doFocus { model | webAngle = w } "web-angle"

        UpdateWebStart w ->
            doFocus { model | webStart = w } "web-start"

        DoCopy id ->
            { model = model
            , command = CopyId id
            }


calculateTruss : Model -> Result String TrussCalc
calculateTruss model =
    let
        parsedModel =
            { chordLen = String.toFloat model.chordLen
            , chordGap = String.toFloat model.chordGap
            , chordHeight = String.toFloat model.chordHeight
            , chordDoubling = String.toInt model.chordDoubling
            , web = String.toFloat model.web
            , startWeb = String.toFloat model.startWeb
            , startCount = String.toInt model.startCount
            , nextWeb = String.toFloat model.nextWeb
            , nextCount = String.toInt model.nextCount
            , roof = String.toFloat model.roof
            , webAngle = String.toFloat model.webAngle
            , webStart = String.toFloat model.webStart
            }
    in
    case parsedModel of
        { chordLen = Just chordLen, chordGap = Just chordGap, chordDoubling = Nothing, web = Just web, startWeb = Nothing, startCount = Nothing, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , chordHeight =
                    parsedModel.chordHeight
                        |> Maybe.withDefault 0
                , chordDoubling = 0
                , web = web
                , startWeb = 0
                , startCount = 0
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Just chordLen, chordGap = Just chordGap, chordHeight = Just chordHeight, chordDoubling = Just chordDoubling, web = Just web, startWeb = Nothing, startCount = Nothing, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , chordHeight = chordHeight
                , chordDoubling = chordDoubling
                , web = web
                , startWeb = 0
                , startCount = 0
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Just chordLen, chordGap = Just chordGap, chordDoubling = Nothing, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , chordHeight =
                    parsedModel.chordHeight
                        |> Maybe.withDefault 0
                , chordDoubling = 0
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Just chordLen, chordGap = Just chordGap, chordHeight = Just chordHeight, chordDoubling = Just chordDoubling, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , chordHeight = chordHeight
                , chordDoubling = chordDoubling
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Just chordLen, chordGap = Just chordGap, chordDoubling = Nothing, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Just nextWeb, nextCount = Just nextCount, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , chordHeight =
                    parsedModel.chordHeight
                        |> Maybe.withDefault 0
                , chordDoubling = 0
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = nextWeb
                , nextCount = nextCount
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Just chordLen, chordGap = Just chordGap, chordHeight = Just chordHeight, chordDoubling = Just chordDoubling, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Just nextWeb, nextCount = Just nextCount, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , chordHeight = chordHeight
                , chordDoubling = chordDoubling
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = nextWeb
                , nextCount = nextCount
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Nothing } ->
            Err "enter the length of the chord"

        { chordGap = Nothing } ->
            Err "enter the gap between the chords"

        { web = Nothing } ->
            Err "enter the width of the web profile"

        { roof = Nothing } ->
            Err "enter the angle of the roof"

        { webAngle = Nothing } ->
            Err "enter the angle that you want the webs to be at"

        { webStart = Nothing } ->
            Err "enter the web start distance"

        -- The user has entered a chord doubling, but not set the chord height
        { chordHeight = Nothing } ->
            Err "enter the height of the chord profile too"

        -- Check the initial webs
        -- The user has entered an initial web width, but not a valid count
        { startCount = Nothing } ->
            case String.toFloat model.startCount of
                Just _ ->
                    -- the user has entered something like 3.5
                    Err "enter an integral number of initial webs"

                Nothing ->
                    -- the user hasn't entered anything
                    Err "enter the number of initial webs too"

        -- The user has entered an initial web count, but not a width
        { startWeb = Nothing } ->
            Err "enter the size of the initial webs"

        -- Check the next webs
        -- The user has entered a next web width, but not a valid count
        { nextCount = Nothing } ->
            case String.toFloat model.nextCount of
                Just _ ->
                    -- the user has entered something like 3.5
                    Err "enter an integral number of next webs"

                Nothing ->
                    -- the user hasn't entered anything
                    Err "enter the number of next webs too"

        -- The user has entered a next web count, but not a width
        { nextWeb = Nothing } ->
            Err "enter the size of the next webs"


view : Model -> Browser.Document Msg
view model =
    { title = "Truss"
    , body =
        [ button
            [ class "left"
            , onClick HomePage
            ]
            [ text "Home"
            ]
        , div
            [ id "truss"
            , class "center"
            ]
            [ h1
                []
                [ text "Truss"
                ]
            , br [] []
            , div
                [ id "truss-inputs"
                , class "center-margin"
                , class "cols-large"
                , style "max-width" "60em"
                ]
                [ makeInput "Chord length" "chord-len" 0.5 model.chordLen UpdateChordLen
                , makeInput "Gap between chords" "chord-gap" 0.5 model.chordGap UpdateChordGap
                , makeInput "Chord height" "chord-height" 0.5 model.chordHeight UpdateChordHeight
                , makeInput "Chord doubling count" "chord-doubling" 1 model.chordDoubling UpdateChordDoubling
                , makeInput "Roof angle" "roof" 0.5 model.roof UpdateRoof
                , makeInput "Web start distance" "web-start" 5 model.webStart UpdateWebStart
                , makeInput "Web profile width" "web" 0.5 model.web UpdateWeb
                , makeInput "Initial web profile width" "start-web" 0.5 model.startWeb UpdateStartWeb
                , makeInput "Initial web count" "start-count" 1 model.startCount UpdateStartCount
                , makeInput "Next web profile width" "next-web" 0.5 model.nextWeb UpdateNextWeb
                , makeInput "Next web count" "next-count" 1 model.nextCount UpdateNextCount
                , makeInput "Web angle" "web-angle" 0.1 model.webAngle UpdateWebAngle
                ]
            , hr [] []
            , case calculateTruss model of
                Err e ->
                    div
                        [ class "center"
                        ]
                        [ text e
                        ]

                Ok { endDistance, webPoints, webLines, lowerChordStart, upperChordStart, lowerChordEnd, upperChordEnd, webOffsetDn, webOffsetUp, chordDoublingRes, chordVert, totals } ->
                    let
                        trussWidth =
                            upperChordEnd.x

                        isDown =
                            upperChordEnd.y < upperChordStart.y

                        trussHeight =
                            if isDown then
                                upperChordStart.y - lowerChordEnd.y + chordVert.y + chordVert.y
                            else
                                upperChordEnd.y + chordVert.y + chordVert.y

                        assumedWidth =
                            1000.0

                        -- 1 pixel in the final
                        sw =
                            trussWidth * 1.0 / assumedWidth

                        vbWidth =
                            trussWidth + sw * 2

                        vbHeight =
                            trussHeight + sw * 2

                        changeCoords : Float2 -> Float2
                        changeCoords { x, y } =
                            { x = x + sw
                            , y =
                                if isDown then
                                    upperChordStart.y - y + sw + chordVert.y
                                else
                                    trussHeight - y + sw - chordVert.y
                            }

                        webLinesMap =
                            webLines
                                |> Array.map
                                        (\{ start, end } ->
                                            { start = changeCoords start
                                            , end = changeCoords end
                                            }
                                        )
                    in
                    div
                        [ class "center"
                        ]
                        [ makeOutput "End distance" "end-distance" endDistance
                        , makeOutputLine "Up distance" "up-distance" webOffsetUp
                        , makeOutputLine "Dn distance" "dn-distance" webOffsetDn
                        , if totals.startWeb /= 0 then
                            makeOutput "Total initial web length" "total-start-web-len" totals.startWeb
                          else
                            text ""
                        , if totals.nextWeb /= 0 then
                            makeOutput "Total next web length" "total-next-web-len" totals.nextWeb
                          else
                            text ""
                        , makeOutput "Total main web length" "total-main-web-len" totals.mainWeb
                        , makeOutput "Total chord length" "total-chord-len" totals.chord
                        , svg
                            [ -- fill the screen when it is small
                              style "width" "clamp(75%, 1000px, 100%)"
                            , viewBox ("0 0 " ++ String.fromFloat vbWidth ++ " " ++ String.fromFloat vbHeight)
                            ]
                            (lines
                                sw
                                (webLinesMap
                                    -- left line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.sub lowerChordStart chordVert)
                                            , end = changeCoords (V2.add upperChordStart chordVert)
                                            }
                                    -- top outer line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.add upperChordStart chordVert)
                                            , end = changeCoords (V2.add upperChordEnd chordVert)
                                            }
                                    -- top inner line
                                    |> Array.pushLast
                                            { start = changeCoords upperChordStart
                                            , end = changeCoords upperChordEnd
                                            }
                                    -- right line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.sub lowerChordEnd chordVert)
                                            , end = changeCoords (V2.add upperChordEnd chordVert)
                                            }
                                    -- bottom outer line
                                    |> Array.pushLast
                                            { start = changeCoords (V2.sub lowerChordStart chordVert)
                                            , end = changeCoords (V2.sub lowerChordEnd chordVert)
                                            }
                                    -- bottom inner line
                                    |> Array.pushLast
                                            { start = changeCoords lowerChordStart
                                            , end = changeCoords lowerChordEnd
                                            }
                                )
                                |> Array.pushLast
                                        (case chordDoublingRes of
                                            Just { start, end } ->
                                                doLine sw (changeCoords start) (changeCoords end)

                                            Nothing ->
                                                text ""
                                        )
                            )
                        ]
            ]
        ]
    }


doLine : Float -> Float2 -> Float2 -> Svg msg
doLine sw start end =
    line
        [ x1 (String.fromFloat start.x)
        , y1 (String.fromFloat start.y)
        , x2 (String.fromFloat end.x)
        , y2 (String.fromFloat end.y)
        , stroke "var(--text)"
        , strokeWidth (String.fromFloat sw)
        ]
        []


lines : Float -> Array LineSeg2 -> Array (Svg msg)
lines sw linesArr =
    linesArr
        |> Array.map (\ls -> doLine sw ls.start ls.end)


polylineF : Float -> Array Float2 -> Svg msg
polylineF sw pointsArr =
    polyline
        [ points
            (pointsArr
                |> Array.map (\{ x, y } -> String.fromFloat x ++ "," ++ String.fromFloat y)
                |> Array.intersperse " "
                |> Array.foldl (++) ""
            )
        , fill "none"
        , stroke "var(--text)"
        , strokeWidth (String.fromFloat sw)
        ]
        []


type alias InputData =
    { label : String
    , idTxt : String
    , stepV : Float
    , currTxt : String
    , updateMsg : String -> Msg
    }


makeInput : String -> String -> Float -> String -> (String -> Msg) -> Html Msg
makeInput label idTxt stepV currTxt updateMsg =
    div
        []
        [ text label
        , br [] []
        , text "         "
        , input
            [ value currTxt
            , onInput updateMsg
            , id idTxt
            , type_ "number"
            , step (String.fromFloat stepV)
            ]
            []
        , if String.isEmpty currTxt then
            button
                [ style "pointer-events" "none"
                , style "opacity" "0"
                , tabindex -1
                ]
                [ text "❌"
                ]
          else
            button
                [ onClick (updateMsg "")
                ]
                [ text "❌"
                ]
        ]


makeOutput : String -> String -> Float -> Html Msg
makeOutput label idTxt calc =
    div
        []
        [ text label
        , br [] []
        , text "         "
        , input
            [ value (String.fromFloat calc)
            , readonly True
            , id idTxt
            , type_ "number"
            ]
            []
        , button
            [ onClick (DoCopy idTxt)
            ]
            [ text "📋"
            ]
        ]


makeOutputLine : String -> String -> Float2 -> Html Msg
makeOutputLine label idTxt { x, y } =
    let
        idX =
            idTxt ++ "-x"

        idY =
            idTxt ++ "-y"
    in
    div
        []
        [ text label
        , br [] []
        , text "         "
        , input
            [ value (String.fromFloat x)
            , readonly True
            , id idX
            , type_ "number"
            ]
            []
        , button
            [ onClick (DoCopy idX)
            ]
            [ text "📋"
            ]
        , input
            [ value (String.fromFloat y)
            , readonly True
            , id idY
            , type_ "number"
            ]
            []
        , button
            [ onClick (DoCopy idY)
            ]
            [ text "📋"
            ]
        ]



-- chordHeight is 90 degrees to the chord


type alias WebData =
    { endPointX : Float
    , webs :
        { offsets :
            { webOffsetUp : Float2
            , webOffsetDn : Float2
            , webOffsetUpCd : Float2
            , webOffsetDnCd : Float2
            , webOffsetVec : Float2
            }
        , mainWebWidth : Float
        , startWebWidth : Float
        , nextWebWidth : Float
        , startCount : Int
        , nextCount : Int
        , webWidthToLenMul : Float
        }
    , chordDoubling : Int
    , chordVert : Float2
    , mainChordLen : Float
    }


calcWebPoints :
    WebData
    -> Float2
    -> Int
    -> { webPoints : Array Float2
       , webLines : Array LineSeg2
       , chordDoublingRes :
            Maybe
                { start : Float2
                , end : Float2
                }
       , totals :
            { startWeb : Float
            , nextWeb : Float
            , mainWeb : Float
            , chord : Float
            }
       }
calcWebPoints dat currWeb index =
    let
        { endPointX, webs, chordDoubling, chordVert, mainChordLen } =
            dat

        { offsets, mainWebWidth, startWebWidth, nextWebWidth, startCount, nextCount, webWidthToLenMul } =
            webs

        { webOffsetUp, webOffsetUpCd, webOffsetDn, webOffsetDnCd, webOffsetVec } =
            offsets
    in
    if currWeb.x > endPointX then
        { webPoints = []
        , webLines = []
        , chordDoublingRes = Nothing
        , totals =
            { startWeb = 0
            , nextWeb = 0
            , mainWeb = 0
            , chord = mainChordLen * 2
            }
        }
    else
        let
            isTop =
                Math.modBy 2 index == 1

            webWidth =
                if index < startCount then
                    startWebWidth
                else if index < startCount + nextCount then
                    nextWebWidth
                else
                    mainWebWidth

            webOffset =
                V2.mul webOffsetVec webWidth

            webLen =
                if index < chordDoubling * 2 - 1 then
                    V2.length webOffsetDnCd + webWidthToLenMul * webWidth
                else
                    V2.length webOffsetDn + webWidthToLenMul * webWidth

            webStartGraphicalOffset =
                if index == 0 && chordDoubling > 0 then
                    chordVert
                else
                    v2 0 0

            webOffsetDir =
                if index < chordDoubling * 2 - 1 then
                    -- 1 goes to just before the second web
                    -- 2 goes to just before the fourth web
                    if isTop then
                        webOffsetDnCd
                    else if index == 0 then
                        V2.add webOffsetUpCd chordVert
                    else
                        webOffsetUpCd
                else if isTop then
                    webOffsetDn
                else
                    webOffsetUp

            nextCurrWeb =
                webOffsetDir
                    |> V2.add currWeb
                    |> V2.add webOffset

            nextDat =
                calcWebPoints dat nextCurrWeb (index + 1)

            isNextWeb =
                not (Array.isEmpty nextDat.webPoints)

            webPoints =
                nextDat.webPoints
                    |> Array.pushFirst currWeb

            webLines =
                if isNextWeb then
                    nextDat.webLines
                        |> Array.pushFirst
                                { start = V2.add currWeb webStartGraphicalOffset
                                , end = V2.add currWeb webOffsetDir
                                }
                        |> Array.pushFirst
                                { start = V2.add (V2.add currWeb webOffset) webStartGraphicalOffset
                                , end = nextCurrWeb
                                }
                else
                    []

            chordDoubleLen =
                if index /= 0 && index == chordDoubling * 2 - 1 then
                    V2.length (V2.add currWeb webOffsetDir)
                else
                    0

            chordDoublingRes =
                if index /= 0 && index == chordDoubling * 2 - 1 then
                    -- the down chord
                    Just
                        { start = chordVert
                        , end = V2.add currWeb webOffsetDnCd
                        }
                else
                    nextDat.chordDoublingRes

            nextTotals =
                nextDat.totals

            startWebLen =
                if index < startCount && isNextWeb then
                    webLen
                else
                    0

            nextWebLen =
                if index >= startCount && index < startCount + nextCount && isNextWeb then
                    webLen
                else
                    0

            mainWebLen =
                if index >= startCount + nextCount && isNextWeb then
                    webLen
                else
                    0

            totals =
                { startWeb = nextTotals.startWeb + startWebLen
                , nextWeb = nextTotals.nextWeb + nextWebLen
                , mainWeb = nextTotals.mainWeb + mainWebLen
                , chord = nextTotals.chord + chordDoubleLen
                }
        in
        { webPoints = webPoints
        , webLines = webLines
        , chordDoublingRes = chordDoublingRes
        , totals = totals
        }


type alias FilledModel =
    { chordLen : Float
    , chordGap : Float
    , chordHeight : Float
    , chordDoubling : Int
    , web : Float
    , startWeb : Float
    , startCount : Int
    , nextWeb : Float
    , nextCount : Int
    , roof : Float
    , webAngle : Float
    , webStart : Float
    }


type alias LineSeg2 =
    { start : Float2
    , end : Float2
    }


type alias TrussCalc =
    { endDistance : Float
    , webPoints : Array Float2
    , webLines : Array LineSeg2
    , lowerChordStart : Float2
    , upperChordStart : Float2
    , lowerChordEnd : Float2
    , upperChordEnd : Float2
    , chordDoublingRes :
        Maybe
            { start : Float2
            , end : Float2
            }
    , webOffsetUp : Float2
    , webOffsetDn : Float2
    , chordVert : Float2
    , totals :
        { startWeb : Float
        , nextWeb : Float
        , mainWeb : Float
        , chord : Float
        }
    }


maybeErr : x -> Bool -> Maybe x -> Maybe x
maybeErr err useDefault orig =
    case orig of
        Nothing ->
            if useDefault then
                Just err
            else
                Nothing

        _ ->
            orig


finishTrussCalc : FilledModel -> Result String TrussCalc
finishTrussCalc { chordLen, chordGap, chordHeight, chordDoubling, web, startWeb, startCount, nextWeb, nextCount, roof, webAngle, webStart = webDist } =
    let
        roofRad =
            Math.degrees roof

        webRad =
            Math.degrees webAngle

        trussAlong =
            v2 (Math.cos roofRad) (Math.sin roofRad)

        webAlongUp =
            v2 (Math.cos (roofRad + webRad)) (Math.sin (roofRad + webRad))

        webAlongDn =
            v2 (Math.cos (roofRad - webRad)) (Math.sin (roofRad - webRad))

        vertGapDist =
            v2 0 (chordGap / Math.cos roofRad)

        endPointLower =
            V2.mul trussAlong chordLen

        endPointUpper =
            V2.add endPointLower vertGapDist

        webStart =
            V2.mul trussAlong webDist

        webOffsetUp =
            V2.div (V2.mul webAlongUp chordGap) (Math.sin webRad)

        webOffsetDn =
            V2.div (V2.mul webAlongDn chordGap) (Math.sin webRad)

        webOffsetUpCd =
            V2.div (V2.mul webAlongUp (chordGap - chordHeight)) (Math.sin webRad)

        webOffsetDnCd =
            V2.div (V2.mul webAlongDn (chordGap - chordHeight)) (Math.sin webRad)

        chordVert =
            v2 0 (chordHeight / Math.cos roofRad)

        mainChordLen =
            chordLen + (chordHeight * Math.tan roofRad)

        dat =
            calcWebPoints
                { endPointX = endPointLower.x
                , webs =
                    { offsets =
                        { webOffsetUp = webOffsetUp
                        , webOffsetDn = webOffsetDn
                        , webOffsetUpCd = webOffsetUpCd
                        , webOffsetDnCd = webOffsetDnCd
                        , webOffsetVec = V2.div trussAlong (Math.sin webRad)
                        }
                    , mainWebWidth = web
                    , startWebWidth = startWeb
                    , nextWebWidth = nextWeb
                    , startCount = startCount
                    , nextCount = nextCount
                    , webWidthToLenMul = 1 / Math.tan webRad
                    }
                , chordDoubling = chordDoubling
                , chordVert = chordVert
                , mainChordLen = mainChordLen
                }
                webStart
                0

        endDistance =
            Array.last dat.webPoints
                |> Maybe.withDefault (v2 0 9999)
                |> (if Math.modBy 2 (Array.length dat.webPoints) == 1 then
                        V2.distance endPointLower
                     else
                        V2.distance endPointUpper
                    )

        -- 6 dp
        formatF : Float -> Float
        formatF value =
            toFloat (Math.round (value * 1000000)) / 1000000

        -- 6 dp
        formatF2 : Float2 -> Float2
        formatF2 { x, y } =
            { x = formatF x
            , y = formatF y
            }

        webMax =
            90 - Math.abs roof

        -- chordLen, chordGap, chordHeight, chordDoubling, web, startWeb, startCount, nextWeb, nextCount, roof, webAngle, webStart = webDist
        error =
            Nothing
                |> maybeErr "chord length should be positive" (chordLen < 0)
                |> maybeErr "gap between chords should be positive" (chordGap < 0)
                |> maybeErr "chord height should be positive" (chordHeight < 0)
                |> maybeErr "chord doubling count should be positive" (chordDoubling < 0)
                |> maybeErr "web profile width should be positive" (web < 0)
                |> maybeErr "initial web profile width should be positive" (startWeb < 0)
                |> maybeErr "initial web count should be positive" (startCount < 0)
                |> maybeErr "next web profile width should be positive" (nextWeb < 0)
                |> maybeErr "next web count should be positive" (nextCount < 0)
                |> maybeErr ("web angle should be less than " ++ String.fromFloat webMax ++ " degrees") (webAngle > webMax)
                |> maybeErr "web angle should be positive" (webAngle < 0)
                |> maybeErr "web start distance should be positive" (webDist < 0)
    in
    case error of
        Just e ->
            Err e

        Nothing ->
            Ok
                { endDistance = formatF endDistance
                , webPoints = dat.webPoints
                , webLines = dat.webLines
                , lowerChordStart =
                    { x = 0.0
                    , y = 0.0
                    }
                , lowerChordEnd = endPointLower
                , upperChordStart = vertGapDist
                , upperChordEnd = endPointUpper
                , chordDoublingRes = dat.chordDoublingRes
                , webOffsetUp = formatF2 webOffsetUp
                , webOffsetDn = formatF2 webOffsetDn
                , chordVert = chordVert
                , totals =
                    { startWeb = formatF dat.totals.startWeb
                    , nextWeb = formatF dat.totals.nextWeb
                    , mainWeb = formatF dat.totals.mainWeb
                    , chord = formatF dat.totals.chord
                    }
                }

module Page.Truss exposing ( Model, Msg(..), update, view, queryParser, queryBuilder )

{-| The truss calculator page
-}

import Browser
import Browser.Dom as Dom
import Html exposing ( Html, br, button, div, hr, input, text )
import Html.Attributes exposing ( class, id, readonly, step, style, type_, value )
import Html.Events exposing ( onClick, onInput )
import Math
import SpaCmd exposing ( SpaCmd(..) )
import Svg exposing ( Svg, line, polyline, svg )
import Svg.Attributes exposing ( fill, points, stroke, strokeWidth, viewBox, width, x1, x2, y1, y2 )
import Task
import Url.Builder as Builder
import Url.Parser.Query as Query
import Vector2 as V2 exposing ( Float2, v2 )


qApply : Query.Parser a -> Query.Parser (a -> b) -> Query.Parser b
qApply argParser funcParser =
    Query.map2 (<|) funcParser argParser


queryParser : Query.Parser Model
queryParser =
    -- We can't do any more than map8
    Query.map
        (\chordLen chordGap web startWeb startCount nextWeb nextCount roof webAngle webStart ->
            { chordLen = Maybe.withDefault "" chordLen
            , chordGap = Maybe.withDefault "" chordGap
            , web = Maybe.withDefault "" web
            , startWeb = Maybe.withDefault "" startWeb
            , startCount = Maybe.withDefault "" startCount
            , nextWeb = Maybe.withDefault "" nextWeb
            , nextCount = Maybe.withDefault "" nextCount
            , roof = Maybe.withDefault "7.5" roof
            , webAngle = Maybe.withDefault "45" webAngle
            , webStart = Maybe.withDefault "125" webStart
            }
        )
        (Query.string "chordLen")
        |> qApply (Query.string "chordGap")
        |> qApply (Query.string "web")
        |> qApply (Query.string "startWeb")
        |> qApply (Query.string "startCount")
        |> qApply (Query.string "nextWeb")
        |> qApply (Query.string "nextCount")
        |> qApply (Query.string "roof")
        |> qApply (Query.string "webAngle")
        |> qApply (Query.string "webStart")


queryBuilder : Model -> Array Builder.QueryParameter
queryBuilder model =
    [ Builder.string "chordLen" model.chordLen
    , Builder.string "chordGap" model.chordGap
    , Builder.string "web" model.web
    , Builder.string "startWeb" model.startWeb
    , Builder.string "startCount" model.startCount
    , Builder.string "nextWeb" model.nextWeb
    , Builder.string "nextCount" model.nextCount
    , Builder.string "roof" model.roof
    , Builder.string "webAngle" model.webAngle
    , Builder.string "webStart" model.webStart
    ]


type alias Model =
    { chordLen : String
    , chordGap : String
    , web : String
    , startWeb : String
    , startCount : String
    , nextWeb : String
    , nextCount : String
    , roof : String
    , webAngle : String
    , webStart : String
    }


type alias Updated =
    { model : Model
    , command : SpaCmd Msg
    }


type Msg
    = HomePage
    | UpdateChordLen String
    | UpdateChordGap String
    | UpdateWeb String
    | UpdateStartWeb String
    | UpdateStartCount String
    | UpdateNextWeb String
    | UpdateNextCount String
    | UpdateRoof String
    | UpdateWebAngle String
    | UpdateWebStart String
    | DoCopy String
    | NoOp


attemptFocus : String -> SpaCmd Msg
attemptFocus id =
    BaseCmd (Task.attempt (\_ -> NoOp) (Dom.focus id))


doFocus : Model -> String -> Updated
doFocus model id =
    { model = model
    , command = attemptFocus id
    }


update : Msg -> Model -> Updated
update msg model =
    case msg of
        NoOp ->
            { model = model
            , command = SpaCmd.none
            }

        HomePage ->
            { model = model
            , command = ChangePage "#/"
            }

        UpdateChordLen c ->
            doFocus { model | chordLen = c } "chord-len"

        UpdateChordGap c ->
            doFocus { model | chordGap = c } "chord-gap"

        UpdateWeb w ->
            doFocus { model | web = w } "web"

        UpdateStartWeb s ->
            doFocus { model | startWeb = s } "start-web"

        UpdateStartCount s ->
            doFocus { model | startCount = s } "start-count"

        UpdateNextWeb s ->
            doFocus { model | nextWeb = s } "next-web"

        UpdateNextCount s ->
            doFocus { model | nextCount = s } "next-count"

        UpdateRoof r ->
            doFocus { model | roof = r } "roof"

        UpdateWebAngle w ->
            doFocus { model | webAngle = w } "web-angle"

        UpdateWebStart w ->
            doFocus { model | webStart = w } "web-start"

        DoCopy id ->
            { model = model
            , command = CopyId id
            }


calculateTruss : Model -> Result String TrussCalc
calculateTruss model =
    let
        parsedModel =
            { chordLen = String.toFloat model.chordLen
            , chordGap = String.toFloat model.chordGap
            , web = String.toFloat model.web
            , startWeb = String.toFloat model.startWeb
            , startCount = String.toInt model.startCount
            , nextWeb = String.toFloat model.nextWeb
            , nextCount = String.toInt model.nextCount
            , roof = String.toFloat model.roof
            , webAngle = String.toFloat model.webAngle
            , webStart = String.toFloat model.webStart
            }
    in
    case parsedModel of
        { chordLen = Just chordLen, chordGap = Just chordGap, web = Just web, startWeb = Nothing, startCount = Nothing, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , web = web
                , startWeb = 0
                , startCount = 0
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Just chordLen, chordGap = Just chordGap, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Nothing, nextCount = Nothing, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = 0
                , nextCount = 0
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Just chordLen, chordGap = Just chordGap, web = Just web, startWeb = Just startWeb, startCount = Just startCount, nextWeb = Just nextWeb, nextCount = Just nextCount, roof = Just roof, webAngle = Just webAngle, webStart = Just webStart } ->
            finishTrussCalc
                { chordLen = chordLen
                , chordGap = chordGap
                , web = web
                , startWeb = startWeb
                , startCount = startCount
                , nextWeb = nextWeb
                , nextCount = nextCount
                , roof = roof
                , webAngle = webAngle
                , webStart = webStart
                }

        { chordLen = Nothing } ->
            Err "enter the length of the chord"

        { chordGap = Nothing } ->
            Err "enter the gap between the chords"

        { web = Nothing } ->
            Err "enter the width of the web profile"

        { roof = Nothing } ->
            Err "enter the angle of the roof"

        { webAngle = Nothing } ->
            Err "enter the angle that you want the webs to be at"

        { webStart = Nothing } ->
            Err "enter the web start distance"

        -- Check the initial webs
        -- The user has entered an initial web width, but not a valid count
        { startCount = Nothing } ->
            case String.toFloat model.startCount of
                Just _ ->
                    -- the user has entered something like 3.5
                    Err "enter an integral number of initial webs"

                Nothing ->
                    -- the user hasn't entered anything
                    Err "enter the number of initial webs too"

        -- The user has entered an initial web count, but not a width
        { startWeb = Nothing } ->
            Err "enter the size of the initial webs"

        -- Check the next webs
        -- The user has entered a next web width, but not a valid count
        { nextCount = Nothing } ->
            case String.toFloat model.nextCount of
                Just _ ->
                    -- the user has entered something like 3.5
                    Err "enter an integral number of next webs"

                Nothing ->
                    -- the user hasn't entered anything
                    Err "enter the number of next webs too"

        -- The user has entered a next web count, but not a width
        { nextWeb = Nothing } ->
            Err "enter the size of the next webs"


view : Model -> Browser.Document Msg
view model =
    let
        result =
            calculateTruss model
    in
    { title = "Truss"
    , body =
        [ button
            [ class "left"
            , onClick HomePage
            ]
            [ text "Home"
            ]
        , div
            [ id "truss"
            , class "center"
            ]
            [ text "Truss"
            , br [] []
            , makeInput "Chord length" "chord-len" 0.5 model.chordLen UpdateChordLen
            , makeInput "Gap between chords" "chord-gap" 0.5 model.chordGap UpdateChordGap
            , makeInput "Web profile width" "web" 0.5 model.web UpdateWeb
            , makeInput "Initial web profile width" "start-web" 0.5 model.startWeb UpdateStartWeb
            , makeInput "Initial web count" "start-count" 1 model.startCount UpdateStartCount
            , makeInput "Next web profile width" "next-web" 0.5 model.nextWeb UpdateNextWeb
            , makeInput "Next web count" "next-count" 1 model.nextCount UpdateNextCount
            , makeInput "Roof angle" "roof" 0.5 model.roof UpdateRoof
            , makeInput "Web angle" "web-angle" 0.1 model.webAngle UpdateWebAngle
            , makeInput "Web start distance" "web-start" 5 model.webStart UpdateWebStart
            , hr [] []
            , case result of
                Err e ->
                    div
                        [ class "center"
                        ]
                        [ text e
                        ]

                Ok { endDistance } ->
                    makeOutput "End distance" "end-distance" endDistance
            , case result of
                Ok { endDistance, webPoints, webLines, lowerChordStart, upperChordStart, lowerChordEnd, upperChordEnd } ->
                    let
                        trussWidth =
                            upperChordEnd.x

                        isDown =
                            upperChordEnd.y < upperChordStart.y

                        trussHeight =
                            if isDown then
                                upperChordStart.y - lowerChordEnd.y
                            else
                                upperChordEnd.y

                        assumedWidth =
                            1000.0

                        -- 1 pixel in the final
                        sw =
                            trussWidth * 1.0 / assumedWidth

                        vbWidth =
                            trussWidth + sw * 2

                        vbHeight =
                            trussHeight + sw * 2

                        changeCoords : Float2 -> Float2
                        changeCoords { x, y } =
                            { x = x + sw
                            , y =
                                if isDown then
                                    upperChordStart.y - y + sw
                                else
                                    trussHeight - y + sw
                            }

                        webLinesMap =
                            webLines
                                |> Array.map
                                        (\{ start, end } ->
                                            { start = changeCoords start
                                            , end = changeCoords end
                                            }
                                        )
                    in
                    svg
                        [ -- fill the screen when it is small
                          style "width" "clamp(75%, 1000px, 100%)"
                        , viewBox ("0 0 " ++ String.fromFloat vbWidth ++ " " ++ String.fromFloat vbHeight)
                        ]
                        (lines sw webLinesMap
                            |> Array.pushLast
                                    ([ lowerChordStart
                                     , lowerChordEnd
                                     , upperChordEnd
                                     , upperChordStart
                                     , lowerChordStart
                                     ]
                                        |> Array.map changeCoords
                                        |> polylineF sw
                                    )
                        )

                Err _ ->
                    text ""
            ]
        ]
    }


lines : Float -> Array LineSeg2 -> Array (Svg msg)
lines sw linesArr =
    linesArr
        |> Array.map
                (\{ start, end } ->
                    line
                        [ x1 (String.fromFloat start.x)
                        , y1 (String.fromFloat start.y)
                        , x2 (String.fromFloat end.x)
                        , y2 (String.fromFloat end.y)
                        , stroke "var(--text)"
                        , strokeWidth (String.fromFloat sw)
                        ]
                        []
                )


polylineF : Float -> Array Float2 -> Svg msg
polylineF sw pointsArr =
    polyline
        [ points
            (pointsArr
                |> Array.map (\{ x, y } -> String.fromFloat x ++ "," ++ String.fromFloat y)
                |> Array.intersperse " "
                |> Array.foldl (++) ""
            )
        , fill "none"
        , stroke "var(--text)"
        , strokeWidth (String.fromFloat sw)
        ]
        []


type alias InputData =
    { label : String
    , idTxt : String
    , stepV : Float
    , currTxt : String
    , updateMsg : String -> Msg
    }


makeInput : String -> String -> Float -> String -> (String -> Msg) -> Html Msg
makeInput label idTxt stepV currTxt updateMsg =
    div
        []
        [ text label
        , text "         "
        , br [] []
        , input
            [ value currTxt
            , onInput updateMsg
            , id idTxt
            , type_ "number"
            , step (String.fromFloat stepV)
            ]
            []
        , if String.isEmpty currTxt then
            button
                [ style "pointer-events" "none"
                , style "opacity" "0"
                ]
                [ text "❌"
                ]
          else
            button
                [ onClick (updateMsg "")
                ]
                [ text "❌"
                ]
        ]


makeOutput : String -> String -> Float -> Html Msg
makeOutput label idTxt calc =
    div
        []
        [ text label
        , br [] []
        , input
            [ value (String.fromFloat calc)
            , readonly True
            , id idTxt
            , type_ "number"
            ]
            []
        , button
            [ onClick (DoCopy idTxt)
            ]
            [ text "📋"
            ]
        ]


type alias WebData =
    { endPointX : Float
    , webOffsetUp : Float2
    , webOffsetDn : Float2
    , webWidthOffset : Float2
    , startWebWidthOffset : Float2
    , startCount : Int
    , nextWebWidthOffset : Float2
    , nextCount : Int
    }


calcWebPoints :
    WebData
    -> Float2
    -> Int
    -> { webPoints : Array Float2
       , webLines : Array LineSeg2
       }
calcWebPoints dat currWeb index =
    let
        { endPointX, webOffsetUp, webOffsetDn, webWidthOffset, startWebWidthOffset, startCount, nextWebWidthOffset, nextCount } =
            dat
    in
    if currWeb.x > endPointX then
        { webPoints = []
        , webLines = []
        }
    else
        let
            isTop =
                Math.modBy 2 index == 1

            webOffset =
                if index < startCount then
                    startWebWidthOffset
                else if index < startCount + nextCount then
                    nextWebWidthOffset
                else
                    webWidthOffset

            webOffsetDir =
                if isTop then
                    webOffsetDn
                else
                    webOffsetUp

            nextCurrWeb =
                webOffsetDir
                    |> V2.add currWeb
                    |> V2.add webOffset

            nextDat =
                calcWebPoints dat nextCurrWeb (index + 1)

            webPoints =
                nextDat.webPoints
                    |> Array.pushFirst currWeb

            webLines =
                if Array.isEmpty nextDat.webPoints then
                    []
                else
                    nextDat.webLines
                        |> Array.pushFirst
                                { start = currWeb
                                , end = V2.add currWeb webOffsetDir
                                }
                        |> Array.pushFirst
                                { start = V2.add currWeb webOffset
                                , end = nextCurrWeb
                                }
        in
        { webPoints = webPoints
        , webLines = webLines
        }


type alias FilledModel =
    { chordLen : Float
    , chordGap : Float
    , web : Float
    , startWeb : Float
    , startCount : Int
    , nextWeb : Float
    , nextCount : Int
    , roof : Float
    , webAngle : Float
    , webStart : Float
    }


type alias LineSeg2 =
    { start : Float2
    , end : Float2
    }


type alias TrussCalc =
    { endDistance : Float
    , webPoints : Array Float2
    , webLines : Array LineSeg2
    , lowerChordStart : Float2
    , upperChordStart : Float2
    , lowerChordEnd : Float2
    , upperChordEnd : Float2
    }


finishTrussCalc : FilledModel -> Result String TrussCalc
finishTrussCalc { chordLen, chordGap, web, startWeb, startCount, nextWeb, nextCount, roof, webAngle, webStart = webDist } =
    let
        roofRad =
            Math.degrees roof

        webRad =
            Math.degrees webAngle

        trussAlong =
            v2 (Math.cos roofRad) (Math.sin roofRad)

        webAlongUp =
            v2 (Math.cos (roofRad + webRad)) (Math.sin (roofRad + webRad))

        webAlongDn =
            v2 (Math.cos (roofRad - webRad)) (Math.sin (roofRad - webRad))

        vertGapDist =
            v2 0 (chordGap / Math.cos roofRad)

        endPointLower =
            V2.mul trussAlong chordLen

        endPointUpper =
            V2.add endPointLower vertGapDist

        webStart =
            V2.mul trussAlong webDist

        webOffsetUp =
            V2.div (V2.mul webAlongUp chordGap) (Math.sin webRad)

        webOffsetDn =
            V2.div (V2.mul webAlongDn chordGap) (Math.sin webRad)

        webWidthOffset =
            V2.mul trussAlong (web / Math.sin webRad)

        startWebWidthOffset =
            V2.mul trussAlong (startWeb / Math.sin webRad)

        nextWebWidthOffset =
            V2.mul trussAlong (nextWeb / Math.sin webRad)

        dat =
            calcWebPoints
                { endPointX = endPointLower.x
                , webOffsetUp = webOffsetUp
                , webOffsetDn = webOffsetDn
                , webWidthOffset = webWidthOffset
                , startWebWidthOffset = startWebWidthOffset
                , startCount = startCount
                , nextWebWidthOffset = nextWebWidthOffset
                , nextCount = nextCount
                }
                webStart
                0

        webPoints =
            dat.webPoints

        webLines =
            dat.webLines

        endDistance =
            Array.last webPoints
                |> Maybe.withDefault (v2 0 9999)
                |> (if Math.modBy 2 (Array.length webPoints) == 1 then
                        V2.distance endPointLower
                     else
                        V2.distance endPointUpper
                    )

        -- 6 dp
        formatF : Float -> Float
        formatF value =
            toFloat (Math.round (value * 1000000)) / 1000000
    in
    Ok
        { endDistance = formatF endDistance
        , webPoints = webPoints
        , webLines = webLines
        , lowerChordStart =
            { x = 0.0
            , y = 0.0
            }
        , lowerChordEnd = endPointLower
        , upperChordStart = vertGapDist
        , upperChordEnd = endPointUpper
        }
